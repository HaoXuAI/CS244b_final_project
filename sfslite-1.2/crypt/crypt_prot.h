// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_CRYPT_PROT_H_INCLUDED__
#define __RPCC_CRYPT_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"
#include "bigint.h"

typedef rpc_opaque<20> _srp_hash;
void *_srp_hash_alloc ();
bool_t xdr__srp_hash (XDR *, void *);
RPC_TYPEDEF_DECL (_srp_hash)


struct srp_msg1 {
  rpc_str<RPC_INFINITY> salt;
  bigint N;
  bigint g;
};
void *srp_msg1_alloc ();
bool_t xdr_srp_msg1 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg1)

template<class T> bool
rpc_traverse (T &t, srp_msg1 &obj)
{
  return rpc_traverse (t, obj.salt)
    && rpc_traverse (t, obj.N)
    && rpc_traverse (t, obj.g);
}



struct srp_msg2 {
  bigint A;
};
void *srp_msg2_alloc ();
bool_t xdr_srp_msg2 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg2)

template<class T> inline bool
rpc_traverse (T &t, srp_msg2 &obj)
{
  return rpc_traverse (t, obj.A);
}



struct srp_msg3 {
  bigint B;
  bigint u;
};
void *srp_msg3_alloc ();
bool_t xdr_srp_msg3 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg3)

template<class T> bool
rpc_traverse (T &t, srp_msg3 &obj)
{
  return rpc_traverse (t, obj.B)
    && rpc_traverse (t, obj.u);
}



struct srp_msg4_src {
  _srp_hash sessid;
  bigint N;
  bigint g;
  rpc_str<RPC_INFINITY> user;
  rpc_str<RPC_INFINITY> salt;
  bigint A;
  bigint B;
  bigint S;
};
void *srp_msg4_src_alloc ();
bool_t xdr_srp_msg4_src (XDR *, void *);
RPC_STRUCT_DECL (srp_msg4_src)

template<class T> bool
rpc_traverse (T &t, srp_msg4_src &obj)
{
  return rpc_traverse (t, obj.sessid)
    && rpc_traverse (t, obj.N)
    && rpc_traverse (t, obj.g)
    && rpc_traverse (t, obj.user)
    && rpc_traverse (t, obj.salt)
    && rpc_traverse (t, obj.A)
    && rpc_traverse (t, obj.B)
    && rpc_traverse (t, obj.S);
}



struct srp_msg5_src {
  _srp_hash sessid;
  bigint A;
  _srp_hash M;
  bigint S;
};
void *srp_msg5_src_alloc ();
bool_t xdr_srp_msg5_src (XDR *, void *);
RPC_STRUCT_DECL (srp_msg5_src)

template<class T> bool
rpc_traverse (T &t, srp_msg5_src &obj)
{
  return rpc_traverse (t, obj.sessid)
    && rpc_traverse (t, obj.A)
    && rpc_traverse (t, obj.M)
    && rpc_traverse (t, obj.S);
}


enum crypt_keytype {
  CRYPT_NOKEY = 0,
  CRYPT_RABIN = 1,
  CRYPT_2SCHNORR = 2,
  CRYPT_SCHNORR = 3,
  CRYPT_1SCHNORR = 4,
  CRYPT_ESIGN = 5,
  CRYPT_PAILLIER = 6,
  CRYPT_ELGAMAL = 7,
};
void *crypt_keytype_alloc ();
bool_t xdr_crypt_keytype (XDR *, void *);
RPC_ENUM_DECL (crypt_keytype)
TYPE2STRUCT( , crypt_keytype);

template<class T> inline bool
rpc_traverse (T &t, crypt_keytype &obj)
{
  u_int32_t val = obj;
  if (!rpc_traverse (t, val))
    return false;
  obj = crypt_keytype (val);
  return true;
}


struct elgamal_ctext {
  bigint r;
  bigint m;
};
void *elgamal_ctext_alloc ();
bool_t xdr_elgamal_ctext (XDR *, void *);
RPC_STRUCT_DECL (elgamal_ctext)

template<class T> bool
rpc_traverse (T &t, elgamal_ctext &obj)
{
  return rpc_traverse (t, obj.r)
    && rpc_traverse (t, obj.m);
}



struct crypt_ctext {
  const crypt_keytype type;
  union {
    union_entry_base _base;
    union_entry<bigint> rabin;
    union_entry<bigint> paillier;
    union_entry<elgamal_ctext> elgamal;
  };

#define rpcunion_tag_crypt_ctext type
#define rpcunion_switch_crypt_ctext(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case CRYPT_RABIN: \
    action (bigint, rabin); \
    break; \
  case CRYPT_PAILLIER: \
    action (bigint, paillier); \
    break; \
  case CRYPT_ELGAMAL: \
    action (elgamal_ctext, elgamal); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  crypt_ctext (crypt_keytype _tag = (crypt_keytype) 0) : type (_tag)
    { _base.init (); set_type (_tag); }
  crypt_ctext (const crypt_ctext &_s)
    : type (_s.type)
    { _base.init (_s._base); }
  ~crypt_ctext () { _base.destroy (); }
  crypt_ctext &operator= (const crypt_ctext &_s) {
    const_cast<crypt_keytype &> (type) = _s.type;
    _base.assign (_s._base);
    return *this;
  }

  void set_type (crypt_keytype _tag) {
    const_cast<crypt_keytype &> (type) = _tag;
    rpcunion_switch_crypt_ctext
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, crypt_ctext &obj)
{
  crypt_keytype tag = obj.type;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.type)
    obj.set_type (tag);

  rpcunion_switch_crypt_ctext
    (obj.type, RPCUNION_TRAVERSE, return true, return false);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
inline bool
rpc_traverse (const stompcast_t &s, crypt_ctext &obj)
{
  rpcunion_switch_crypt_ctext
    (obj.type, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *crypt_ctext_alloc ();
bool_t xdr_crypt_ctext (XDR *, void *);
RPC_UNION_DECL (crypt_ctext)

#endif /* !__RPCC_CRYPT_PROT_H_INCLUDED__ */
