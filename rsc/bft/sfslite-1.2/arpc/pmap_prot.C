#define proc XXX_egcs_bug_proc
#include "sysconf.h"
#undef proc
// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "pmap_prot.h"

#ifdef MAINTAINER

const strbuf &
rpc_print (const strbuf &sb, const mapping &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "mapping " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.prog, recdepth, "prog", npref);
  sb << sep;
  rpc_print (sb, obj.vers, recdepth, "vers", npref);
  sb << sep;
  rpc_print (sb, obj.prot, recdepth, "prot", npref);
  sb << sep;
  rpc_print (sb, obj.port, recdepth, "port", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_mapping (const void *_objp, const strbuf *_sbp, int _recdepth,
               const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const mapping *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_mapping (const mapping *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const pmaplist &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "pmaplist " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.map, recdepth, "map", npref);
  sb << sep;
  rpc_print (sb, obj.next, recdepth, "next", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_pmaplist (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const pmaplist *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_pmaplist (const pmaplist *objp)
{
  rpc_print (warnx, *objp);
}

void
print_pmaplist_ptr (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const pmaplist_ptr *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_pmaplist_ptr (const pmaplist_ptr *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const call_args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "call_args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.prog, recdepth, "prog", npref);
  sb << sep;
  rpc_print (sb, obj.vers, recdepth, "vers", npref);
  sb << sep;
  rpc_print (sb, obj.proc, recdepth, "proc", npref);
  sb << sep;
  rpc_print (sb, obj.args, recdepth, "args", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_call_args (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const call_args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_call_args (const call_args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const call_result &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "call_result " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.port, recdepth, "port", npref);
  sb << sep;
  rpc_print (sb, obj.res, recdepth, "res", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_call_result (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const call_result *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_call_result (const call_result *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
mapping_alloc ()
{
  return New mapping;
}
bool_t
xdr_mapping (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<mapping *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<mapping *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
pmaplist_alloc ()
{
  return New pmaplist;
}
bool_t
xdr_pmaplist (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<pmaplist *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<pmaplist *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
pmaplist_ptr_alloc ()
{
  return New pmaplist_ptr;
}
bool_t
xdr_pmaplist_ptr (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<pmaplist_ptr *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<pmaplist_ptr *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
call_args_alloc ()
{
  return New call_args;
}
bool_t
xdr_call_args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<call_args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<call_args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
call_result_alloc ()
{
  return New call_result;
}
bool_t
xdr_call_result (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<call_result *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<call_result *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

static const rpcgen_table pmap_prog_2_tbl[] = {
  PMAP_PROG_2_APPLY (XDRTBL_DECL)
};
const rpc_program pmap_prog_2 = {
  PMAP_PROG, PMAP_VERS, pmap_prog_2_tbl,
  sizeof (pmap_prog_2_tbl) / sizeof (pmap_prog_2_tbl[0]),
  "pmap_prog_2"
};


