// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "crypt_prot.h"

#ifdef MAINTAINER

void
print__srp_hash (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const _srp_hash *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump__srp_hash (const _srp_hash *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const srp_msg1 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "srp_msg1 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.salt, recdepth, "salt", npref);
  sb << sep;
  rpc_print (sb, obj.N, recdepth, "N", npref);
  sb << sep;
  rpc_print (sb, obj.g, recdepth, "g", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_srp_msg1 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const srp_msg1 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_srp_msg1 (const srp_msg1 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const srp_msg2 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "srp_msg2 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.A, recdepth, "A", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_srp_msg2 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const srp_msg2 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_srp_msg2 (const srp_msg2 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const srp_msg3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "srp_msg3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.B, recdepth, "B", npref);
  sb << sep;
  rpc_print (sb, obj.u, recdepth, "u", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_srp_msg3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const srp_msg3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_srp_msg3 (const srp_msg3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const srp_msg4_src &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "srp_msg4_src " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.sessid, recdepth, "sessid", npref);
  sb << sep;
  rpc_print (sb, obj.N, recdepth, "N", npref);
  sb << sep;
  rpc_print (sb, obj.g, recdepth, "g", npref);
  sb << sep;
  rpc_print (sb, obj.user, recdepth, "user", npref);
  sb << sep;
  rpc_print (sb, obj.salt, recdepth, "salt", npref);
  sb << sep;
  rpc_print (sb, obj.A, recdepth, "A", npref);
  sb << sep;
  rpc_print (sb, obj.B, recdepth, "B", npref);
  sb << sep;
  rpc_print (sb, obj.S, recdepth, "S", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_srp_msg4_src (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const srp_msg4_src *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_srp_msg4_src (const srp_msg4_src *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const srp_msg5_src &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "srp_msg5_src " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.sessid, recdepth, "sessid", npref);
  sb << sep;
  rpc_print (sb, obj.A, recdepth, "A", npref);
  sb << sep;
  rpc_print (sb, obj.M, recdepth, "M", npref);
  sb << sep;
  rpc_print (sb, obj.S, recdepth, "S", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_srp_msg5_src (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const srp_msg5_src *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_srp_msg5_src (const srp_msg5_src *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const crypt_keytype &obj, int recdepth,
           const char *name, const char *prefix)
{
  const char *p;
  switch (obj) {
  case CRYPT_NOKEY:
    p = "CRYPT_NOKEY";
    break;
  case CRYPT_RABIN:
    p = "CRYPT_RABIN";
    break;
  case CRYPT_2SCHNORR:
    p = "CRYPT_2SCHNORR";
    break;
  case CRYPT_SCHNORR:
    p = "CRYPT_SCHNORR";
    break;
  case CRYPT_1SCHNORR:
    p = "CRYPT_1SCHNORR";
    break;
  case CRYPT_ESIGN:
    p = "CRYPT_ESIGN";
    break;
  case CRYPT_PAILLIER:
    p = "CRYPT_PAILLIER";
    break;
  case CRYPT_ELGAMAL:
    p = "CRYPT_ELGAMAL";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "crypt_keytype " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_crypt_keytype (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const crypt_keytype *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_crypt_keytype (const crypt_keytype *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const elgamal_ctext &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "elgamal_ctext " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.r, recdepth, "r", npref);
  sb << sep;
  rpc_print (sb, obj.m, recdepth, "m", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_elgamal_ctext (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const elgamal_ctext *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_elgamal_ctext (const elgamal_ctext *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const crypt_ctext &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "crypt_ctext " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.type, recdepth, "type", npref);
  switch (obj.type) {
  case CRYPT_RABIN:
    sb << sep;
    rpc_print (sb, *obj.rabin,  recdepth, "rabin", npref);
    break;
  case CRYPT_PAILLIER:
    sb << sep;
    rpc_print (sb, *obj.paillier,  recdepth, "paillier", npref);
    break;
  case CRYPT_ELGAMAL:
    sb << sep;
    rpc_print (sb, *obj.elgamal,  recdepth, "elgamal", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_crypt_ctext (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const crypt_ctext *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_crypt_ctext (const crypt_ctext *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
_srp_hash_alloc ()
{
  return New _srp_hash;
}
bool_t
xdr__srp_hash (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<_srp_hash *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<_srp_hash *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
srp_msg1_alloc ()
{
  return New srp_msg1;
}
bool_t
xdr_srp_msg1 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<srp_msg1 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<srp_msg1 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
srp_msg2_alloc ()
{
  return New srp_msg2;
}
bool_t
xdr_srp_msg2 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<srp_msg2 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<srp_msg2 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
srp_msg3_alloc ()
{
  return New srp_msg3;
}
bool_t
xdr_srp_msg3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<srp_msg3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<srp_msg3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
srp_msg4_src_alloc ()
{
  return New srp_msg4_src;
}
bool_t
xdr_srp_msg4_src (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<srp_msg4_src *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<srp_msg4_src *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
srp_msg5_src_alloc ()
{
  return New srp_msg5_src;
}
bool_t
xdr_srp_msg5_src (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<srp_msg5_src *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<srp_msg5_src *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
crypt_keytype_alloc ()
{
  return New crypt_keytype;
}
bool_t
xdr_crypt_keytype (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<crypt_keytype *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<crypt_keytype *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
elgamal_ctext_alloc ()
{
  return New elgamal_ctext;
}
bool_t
xdr_elgamal_ctext (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<elgamal_ctext *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<elgamal_ctext *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
crypt_ctext_alloc ()
{
  return New crypt_ctext;
}
bool_t
xdr_crypt_ctext (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<crypt_ctext *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<crypt_ctext *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}


